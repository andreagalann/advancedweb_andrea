<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="../assets/css/dtrends.css" />
    <!-- Relative path -->
  </head>
  <body>
    <div class="header">
      <h1>MAKE IT BIGGER</h1>
      <p class="subtitle" id="subtitle-main">
        TURNING THE Ordinary INTO THE UNREAL
      </p>
    </div>

    <div class="parallax-bg">
      <div></div>
    </div>

    <div class="content">
      <h2>Why BIGGER</h2>
      <p>
        Thereâ€™s something magnetic about scale. Not just in size, but in
        presence. In the way an image fills the space, stretches the limits of
        what feels possible, and dares to occupy more than it should. We used to
        think balance was elegance â€” now, itâ€™s excess that speaks louder.
        Details that refuse to hide, compositions that donâ€™t apologize for
        existing. Every pixel wants to be seen, every frame wants to breathe a
        little louder. Maybe itâ€™s not about being big for the sake of it. Maybe
        itâ€™s about reminding the world that imagination doesnâ€™t fit inside the
        frame.
      </p>
      <p class="bold1" id="bold-main">BIGGER ISNâ€™T A SIZE. ITâ€™S AN ATTITUDE.</p>

      <h2>The Noise Of Silence</h2>
      <p>
        In a world where everything whispers, boldness becomes the only volume
        worth hearing. Minimalism had its moment â€” clean lines, muted tones,
        quiet perfection. But silence fades fast. The eye craves energy,
        contrast, exaggeration.
      </p>
      <p>
        Thereâ€™s beauty in the overload: colors that clash with purpose, shapes
        that challenge proportion, light that blinds just enough to feel alive.
        Itâ€™s not chaos â€” itâ€™s confidence.
      </p>
      <p>
        To create now is to speak louder. To design is to let the noise become
        music. Because sometimes, what feels â€œtoo muchâ€ is exactly what weâ€™ve
        been missing.
      </p>

      <div class="code-box">
        <code>
          Â· Â· â€” Â·Â·Â· Â· â€” Â· â€” Â·Â·Â· â€” Â· Â· Â· Â· â€” â€” Â·Â·Â· â€” â€” Â· Â· â€” Â· Â· â€” Â·Â·Â· â€” â€” Â· Â· â€”
          Â· Â· Â·Â·Â· â€” Â· â€” Â· Â· â€” Â·Â·Â· â€” â€” .
        </code>
      </div>

      <div class="comparisonone">
        <h3>The New Scale</h3>
        <ul>
          <li>
            <strong>EDesign used to serve the message</strong>
          </li>
          <li>
            <strong>Now, it is the message</strong>
          </li>
          <li>
            <strong>The frame no longer contains:</strong>
            it explodes
          </li>
        </ul>
        <h3></h3>
        <ul></ul>
      </div>

      <div class="reflection">
        <strong>Atelier Reflection:</strong>
        Does the parallax effect make this page feel more "alive"? Why or why
        not? Does it enhance your understanding of the content, or is it purely
        decorative? Consider the balance between visual interest and
        accessibility.
      </div>
    </div>

    <div class="normal-bg">
      <div>Normal Scrolling Background</div>
    </div>

    <div class="content">
      <h2>Comparison: Normal Scrolling</h2>
      <p>
        The section above uses
        <code>background-attachment: scroll</code>
        (the default). Notice how it scrolls with the content instead of staying
        fixed. This is the traditional approach.
      </p>

      <div class="comparison">
        <h3>Key Differences:</h3>
        <ul>
          <li>
            <strong>Parallax (fixed):</strong>
            Background stays in place, content moves over it
          </li>
          <li>
            <strong>Normal (scroll):</strong>
            Background and content move together at the same speed
          </li>
        </ul>
        <p>
          <strong>Tip:</strong>
          Scroll up and down this page multiple times to really feel the
          difference between the purple (parallax) and green (normal) sections!
        </p>
      </div>

      <h2>Mobile Considerations</h2>
      <p>
        On mobile devices,
        <code>background-attachment: fixed</code>
        often doesn't work due to browser limitations. The CSS in this demo
        automatically switches to regular scrolling on smaller screens to ensure
        a good experience for all users.
      </p>

      <div class="reflection">
        <strong>Critical Design Question:</strong>
        Is the parallax effect truly enhancing the user experience, or could it
        be a barrier? Consider users with vestibular disorders who may
        experience discomfort with motion effects. How might we offer
        alternatives or respect the
        <code>prefers-reduced-motion</code>
        media query?
      </div>
    </div>

    <!-- JavaScript-based Parallax with Multiple Layers -->
    <div class="parallax-js-section" id="js-parallax">
      <div class="parallax-layer layer-back" data-speed="0.2">ğŸŒŒ</div>
      <div class="parallax-layer layer-middle" data-speed="0.5">â˜ï¸</div>
      <div class="parallax-layer layer-front" data-speed="0.8">
        JavaScript Parallax
      </div>
      <div class="speed-indicator">
        Scroll to see 3 layers moving at different speeds
      </div>
    </div>

    <div class="content">
      <h2>Technique 2: JavaScript Parallax with transform</h2>
      <p>
        The section above uses
        <strong>
          JavaScript with
          <code>transform: translateY()</code>
        </strong>
        to move elements at different speeds. This offers more control than pure
        CSS.
      </p>

      <div class="code-box">
        <code>
          // Each layer has a data-speed attribute
          <br />
          const layer = document.querySelector('.layer-back');
          <br />
          const speed = layer.dataset.speed; // 0.2 = very slow
          <br />
          <br />
          window.addEventListener('scroll', () =&gt; {
          <br />
          &nbsp;&nbsp;const scrolled = window.pageYOffset;
          <br />
          &nbsp;&nbsp;const yPos = -(scrolled * speed);
          <br />
          &nbsp;&nbsp;layer.style.transform = `translateY(${yPos}px)`;
          <br />
          });
        </code>
      </div>

      <div class="comparison">
        <h3>Advantages of JavaScript Parallax:</h3>
        <ul>
          <li>
            <strong>Precise Control:</strong>
            You can control exactly how fast each layer moves
          </li>
          <li>
            <strong>Multiple Elements:</strong>
            Move any HTML element, not just backgrounds
          </li>
          <li>
            <strong>Works on Mobile:</strong>
            Unlike
            <code>background-attachment: fixed</code>
          </li>
          <li>
            <strong>Complex Animations:</strong>
            Combine with opacity, scale, rotation, etc.
          </li>
        </ul>
        <h3>âš ï¸ Considerations:</h3>
        <ul>
          <li>Requires JavaScript (fallback if JS is disabled)</li>
          <li>
            Use
            <code>requestAnimationFrame</code>
            for better performance
          </li>
          <li>
            Respect
            <code>prefers-reduced-motion</code>
          </li>
        </ul>
      </div>
    </div>

    <!-- Image-based Parallax Layers -->
    <div class="parallax-image-section" id="image-parallax">
      <div class="image-layer image-layer-1" data-speed="0.3"></div>
      <div class="image-layer image-layer-2" data-speed="0.6"></div>
      <div class="image-layer image-layer-3" data-speed="0.9"></div>
      <div class="speed-indicator">
        3 image layers â€¢ Speeds: slow (0.3) â†’ medium (0.6) â†’ fast (0.9)
      </div>
    </div>

    <div class="content">
      <h2>Technique 3: Multi-Layer Images</h2>
      <p>
        The section above combines multiple background images moving at
        different speeds to create a 3D depth effect.
      </p>

      <div class="comparison">
        <h3>ğŸ“Š Comparison of All 3 Techniques:</h3>
        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem">
          <tbody>
            <tr style="background: #f8f9fa; font-weight: bold">
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                Technique
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                Implementation
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                Mobile Support
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                Complexity
              </td>
            </tr>
            <tr>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                <strong>CSS Fixed</strong>
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                background-attachment: fixed
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                âŒ Limited
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                â­ Very simple
              </td>
            </tr>
            <tr>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                <strong>JS Transform</strong>
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                transform: translateY()
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                âœ… Works
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                â­â­ Medium
              </td>
            </tr>
            <tr>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                <strong>Multi-layer</strong>
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                Multiple elements + JS
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                âœ… Works
              </td>
              <td style="padding: 0.75rem; border: 1px solid #dee2e6">
                â­â­â­ Advanced
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="reflection">
        <strong>Final Reflection:</strong>
        Which technique do you prefer? CSS is perfect for simple sites.
        JavaScript offers full control but requires more code. Multi-layer
        creates the most impressive effects but may impact performance.
        <strong>The best choice depends on your specific project.</strong>
      </div>
    </div>

    <script>
      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      );
      let isReducedMotion = prefersReducedMotion.matches;

      // Handle CSS-based parallax
      function handleMotionPreference() {
        const parallaxElements = document.querySelectorAll(".parallax-bg");

        if (isReducedMotion) {
          // User prefers reduced motion - disable parallax
          parallaxElements.forEach((el) => {
            el.style.backgroundAttachment = "scroll";
          });
          console.log("Parallax disabled: user prefers reduced motion");
        }
      }

      // JavaScript-based Parallax Implementation
      function initParallax() {
        if (isReducedMotion) {
          console.log(
            "JS Parallax disabled: respecting reduced motion preference"
          );
          return;
        }

        const parallaxLayers = document.querySelectorAll(
          ".parallax-layer, .image-layer"
        );
        let ticking = false;

        function updateParallax() {
          parallaxLayers.forEach((layer) => {
            const speed = parseFloat(layer.dataset.speed) || 0.5;
            const section = layer.parentElement;
            const rect = section.getBoundingClientRect();

            // Only animate when section is in viewport
            if (rect.top < window.innerHeight && rect.bottom > 0) {
              // Calculate scroll position relative to section's position
              const sectionTop = section.offsetTop;
              const scrolled = window.pageYOffset;
              const offset = scrolled - sectionTop;
              const yPos = offset * speed * 0.5; // Multiply by 0.5 to reduce movement

              // Use transform for better performance
              layer.style.transform = `translateY(${yPos}px)`;
            }
          });

          ticking = false;
        }

        function requestTick() {
          if (!ticking) {
            requestAnimationFrame(updateParallax);
            ticking = true;
          }
        }

        // Throttle scroll events using requestAnimationFrame
        window.addEventListener("scroll", requestTick, { passive: true });

        // Initial update
        updateParallax();
      }

      // Initialize everything
      handleMotionPreference();
      initParallax();

      // Listen for motion preference changes
      prefersReducedMotion.addEventListener("change", (e) => {
        isReducedMotion = e.matches;
        handleMotionPreference();

        if (isReducedMotion) {
          // Reset all transforms
          document
            .querySelectorAll(".parallax-layer, .image-layer")
            .forEach((layer) => {
              layer.style.transform = "translateY(0)";
            });
        } else {
          initParallax();
        }
      });

      // Log performance info for learning
      console.log("ğŸ¬ Parallax Demo Loaded");
      console.log(
        "ğŸ“Š Layers detected:",
        document.querySelectorAll(".parallax-layer, .image-layer").length
      );
      console.log(
        "â™¿ Reduced motion:",
        isReducedMotion ? "ENABLED" : "DISABLED"
      );
    </script>

    <div id="my-app"></div>
  </body>
</html>
